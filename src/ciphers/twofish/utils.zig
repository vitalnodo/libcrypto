const std = @import("std");
const rotr = std.math.rotr;

pub const rounds = 16;
pub const rho = 16843009; // 2^24 + 2^16 + 2^8 + 2^0
pub const POLYNOM_V = 0b101101001; // x^8 + x^6 + x^5 + x^3 + 1
pub const POLYNOM_W = 0b101001101; // x^8 + x^6 + x^3 + x^2 + 1
fn generateQ(
    t: [4][16]u4,
) [256]u8 {
    var q: [256]u8 = undefined;
    var a: [5]u8 = .{ 0, 0, 0, 0, 0 };
    var b: [5]u8 = .{ 0, 0, 0, 0, 0 };
    for (0..256) |i| {
        a[0] = i >> 4;
        b[0] = i & 0xf;
        a[1] = a[0] ^ b[0];
        b[1] = a[0] ^ rotr(u4, b[0], 1) ^ ((a[0] << 3) & 8);
        a[2] = t[0][a[1]];
        b[2] = t[1][b[1]];
        a[3] = a[2] ^ b[2];
        b[3] = a[2] ^ rotr(u4, b[2], 1) ^ ((a[2] << 3) & 8);

        a[4] = t[2][a[3]];
        b[4] = t[3][b[3]];

        q[i] = b[4] << 4 | a[4];
    }
    return q;
}

pub const Q0 = blk: {
    const t: [4][16]u4 = .{ .{
        0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2, 0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4,
    }, .{
        0xE, 0xC, 0xB, 0x8, 0x1, 0x2, 0x3, 0x5, 0xF, 0x4, 0xA, 0x6, 0x7, 0x0, 0x9, 0xD,
    }, .{
        0xB, 0xA, 0x5, 0xE, 0x6, 0xD, 0x9, 0x0, 0xC, 0x8, 0xF, 0x3, 0x2, 0x4, 0x7, 0x1,
    }, .{
        0xD, 0x7, 0xF, 0x4, 0x1, 0x2, 0x6, 0xE, 0x9, 0xB, 0x3, 0x0, 0x8, 0x5, 0xC, 0xA,
    } };
    const q0 = generateQ(t);
    break :blk q0;
};

pub const Q1 = blk: {
    const t: [4][16]u4 = .{ .{
        0x2, 0x8, 0xB, 0xD, 0xF, 0x7, 0x6, 0xE, 0x3, 0x1, 0x9, 0x4, 0x0, 0xA, 0xC, 0x5,
    }, .{
        0x1, 0xE, 0x2, 0xB, 0x4, 0xC, 0x3, 0x7, 0x6, 0xD, 0xA, 0x5, 0xF, 0x9, 0x0, 0x8,
    }, .{
        0x4, 0xC, 0x7, 0x5, 0x1, 0x6, 0x9, 0xA, 0x0, 0xE, 0xD, 0x8, 0x2, 0xB, 0x3, 0xF,
    }, .{
        0xB, 0x9, 0x5, 0x1, 0xC, 0x3, 0xD, 0xE, 0x6, 0x4, 0x7, 0xF, 0x2, 0x0, 0x8, 0xA,
    } };
    const q1: [256]u8 = generateQ(t);
    break :blk q1;
};

pub fn gf256_mul(a: u8, b: u8, polynomial: u32) u8 {
    var a_: u8 = a;
    var B = [2]u32{ 0, b };
    const P = [2]u32{ 0, polynomial };
    var result: u32 = undefined;

    // branchless GF multiplier
    for (0..8) |_| {
        result ^= B[a_ & 1];
        a_ >>= 1;
        B[1] = P[B[1] >> 7] ^ (B[1] << 1);
    }
    result ^= B[a_ & 1];
    return @intCast(result & 0xff);
}

pub const MDS = [4][4]u8{
    [4]u8{ 0x01, 0xEF, 0x5B, 0x5B },
    [4]u8{ 0x5B, 0xEF, 0xEF, 0x01 },
    [4]u8{ 0xEF, 0x5B, 0x01, 0xEF },
    [4]u8{ 0xEF, 0x01, 0xEF, 0x5B },
};

pub const RS = &[4][8]u8{
    [_]u8{ 0x01, 0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E },
    [_]u8{ 0xA4, 0x56, 0x82, 0xF3, 0x1E, 0xC6, 0x68, 0xE5 },
    [_]u8{ 0x02, 0xA1, 0xFC, 0xC1, 0x47, 0xAE, 0x3D, 0x19 },
    [_]u8{ 0xA4, 0x55, 0x87, 0x5A, 0x58, 0xDB, 0x9E, 0x03 },
};

pub fn gf256_matmul0(v: [8]u8) [4]u8 {
    var out: [4]u8 = .{ 0, 0, 0, 0 };
    for (0..RS.len) |i| {
        for (0..v.len) |k| {
            out[i] ^= gf256_mul(RS[i][k], v[k], 0x14D);
        }
    }
    return out;
}

pub fn matmult(
    comptime a: usize,
    comptime b: usize,
    comptime c: usize,
    A: [a][b]u8,
    B: [b][c]u8,
    polynomial: u32,
) [a][c]u8 {
    var C: [a][c]u8 = undefined;
    @memset(std.mem.asBytes(&C), 0);
    for (0..a) |i| {
        for (0..c) |j| {
            for (0..b) |k| {
                C[i][j] ^= gf256_mul(A[i][k], B[k][j], polynomial);
            }
        }
    }
    return C;
}
